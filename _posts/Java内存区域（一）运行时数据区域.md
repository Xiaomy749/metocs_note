---
title: Java内存区域（一）运行时数据区域
cover: https://cdn.jsdelivr.net/gh/Xiaomy749/metocs_pic/202112052056838.png
date: 2021-11-29 22:06:51
tags:
- Java
- Jvm笔记
categories:
- [Java,Jvm笔记]
---

Java 虚拟机在执行Java程序的时候会把他所管理的内存区域划分成若干个不同的数据区域。这些区域有各自的用途及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在。有的区域则是依赖用户线程的启动和结束而建立和销毁。

![](https://cdn.jsdelivr.net/gh/Xiaomy749/metocs_pic/202111292221629.jpg)

​																												*图 1-1 java虚拟机运行时数据区*

### 一、运行时数据区域

#### 1.程序计数器

程序计数器是一块较小的内存空间，可看作为当前线程执行的字节码的行号指示器。字节码通过该计数器的值选取下一条要执行的字节码命令。分支、循环、跳转、异常处理、线程恢复等都需要依赖此计数器完成。

各条线程之间计数器互不影响，独立存储。这类内存区域称为“线程私有”的内存

如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果是本地（Native）方法，则计数器对应值为空（Undefined）

此区域是唯一在《Java虚拟机规范》中没有规定任何 `OutOfMemoryError` 情况的区域

#### 2.Java 虚拟机栈

与程序计数器一样，Java虚拟机栈也是线程私有的。它的生命周期和线程的生命周期相同。Java虚拟机栈是描述Java方法执行的线程模型。每个方法被执行的时候，Java虚拟机栈都会同步创建一个栈帧，每个方法被调用直至执行完毕的过程就对应着一个栈帧在虚拟机栈中从入栈到出战的过程。

栈中存储内容：

- 局部变量表

- 操作数栈

- 动态连接

- 方法出口等

  

局部表量表：

1. 局部变量表存放了编译器可知的各种Java虚拟机基本数据类型（`boolean`，`byte`，`char`，`short`，`int`，`float`，`long`，`double`）
2. 对象引用（`reference`类型，它并不是对象本身，可能是一个指向对象起始地址的引用指针，也可能时指向代表对象的句柄或其他与此对象相关的位置）
3. `returnAddress`类型（指向了一条字节码指令的地址）

这些数据类型在局部变量表的存储空间中以局部变量槽（Slot）表示，其中64位长度的`long`与`double`数据会占用两个变量槽，其余占用一个。

局部变量表所需的内存空间是在编译期完成分配的，当进入一个方法时，这个方法所需分配的空间大小是完全确定的。（注意这里的大小指的时变量槽的数量的多少）

**栈** 通常情况下指虚拟机栈，或更多情况下只是指虚拟机栈中局部变量表的部分。

此区域的两种异常情况

- `StackOverflowError`异常： 线程请求的栈深度大于虚拟机所允许的深度。
- `OutOfMemoryError`异常：如果Java虚拟机的栈容量可以动态扩展，当栈扩展时无法申请到足够的内存的时候会抛出。（大部分虚拟机的栈容量时不可以动态扩展的，但是线程申请空间失败仍会抛出OOM异常）

#### 3.本地方法栈

本地方法栈与虚拟机栈所发挥的作用非常相似，其区别在于虚拟机栈为执行Java方法（字节码）服务，而本地方法栈是为虚拟机使用到的本地（Native）方法服务。

《Java虚拟机规范》对本地方法栈中的方法使用的语言、使用方式与数据结构并没有任何强制规定。虚拟机可根据需要自行实现。有的虚拟机将虚拟机栈与本地方法栈合二为一如 HotSpot 虚拟机

此区域的两种异常情况与虚拟机栈基本相似

- `StackOverflowError`异常
- `OutOfMemoryError`异常

#### 4.Java堆

对于Java应用程序来说，Java堆（Java heap）是虚拟机的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例。Java世界里"几乎"所有对象实例都在这里分配内存。

Java堆时垃圾收集器管理的内存区域。因此也被称为 "GC堆"。

现代垃圾收集器大部分都是基于分代收集理论设计的。

Java堆中经常会出现以下名称

- 新生代
- 老年代
- 永久代 
- Eden空间
- From Survivor 空间
- To Survivor 空间

从内存分配的角度来看，所有的线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer ，TLAB ).，以提升对象分配的效率。

![TLAB示意图](https://cdn.jsdelivr.net/gh/Xiaomy749/metocs_pic/202112012024611.jpg)

​																													*图 1-2 TLAB示意图*

Java堆既可以被实现成固定大小的也可以是可扩展的，不过当前主流的Java虚拟机都是按可扩展来实现的

- -`Xms` ：设定最小堆空间
- -`Xmx` ：设定最大堆空间

如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出`OutOfMemoryError`异常 

#### 5.1方法区

方法区（Method Area）与Java堆一样，是一个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分， 但却有一个别名 “非堆” 目的是与Java堆区别开来。

“永久代” Java 8 之前再HotSpot 虚拟机中选择把收集器的分代设计扩展至方法区。或者说永久代是方法区的实现方式。

JDK 7 HotSpot 将原本放在永久代的字符串常量池、静态变量等移至Java堆中。JDK8 完全放弃了 “永久代” 改用在本地内存中实现元空间（Meta-space）代替。

#### 5.2 运行时常量池

运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用。这部分内容将在类加载后存放到方法区的运行时常量池中。

运行时常量池相对于Class文件常量池的一个重要特征时具备动态性。Java语言并不要求常量一定只有编译器才能产生，也就是说并非预置在Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中。

运行时常量池是方法区的一部分，与方法区一样当无法在申请到内存是会抛出`OutOfMemoryError`异常。

#### 6.直接内存

直接内存并不是虚拟机运行时数据区的一部分。也不时《Java虚拟机规范》中定义的内存区域。

在JDK1.4中新加入了`NIO`类（new Input/output）类。引入了一种基于通道（channel）与缓冲区（Buffer）的 I/O 方式。它可以使用 Native 函数库直接分配堆外内存，然后通过一个在Java堆里面的`DirectByteBuffer` 对象作为这块内存的引用进行操作。避免Java堆和Native堆中来回复制数据。

本地内存的分配不会受到Java堆大小的限制。因此在通过 `-Xmx` 进行设置时可能会忽略掉直接内存导致内存区域总和超出物理内存限制，导致动态扩展时出现 

`OutOfMemoryError` 异常

![](https://cdn.jsdelivr.net/gh/Xiaomy749/metocs_pic/202112052056838.png)

​																												图 1-3 Java内存模型示意图*

