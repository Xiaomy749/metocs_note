---
title: 垃圾收集器（二）算法实现细节
date: 2022-01-15 15:07:23
tags:
- Java
- Jvm笔记
categories:
- [Java,Jvm笔记]

---

### 概述

Java虚拟机实现判断对象存活与垃圾收集的算法时，必须对算法的执行效率有严格的考量，才能保证虚拟机的高效运行。以下内容是为了为各款垃圾收集器做前置的知识铺垫。

(先记录下来慢慢理解)

### 根节点枚举

我们可以从可达性分析算法中从GC Roots 集合找引用链这个操作介绍虚拟机高效实现的第一个例子。固定可作为 GC Roots 的节点主要在全局性的引用（例如常量或静态属性）与执行上下文（例如栈帧中的本地变量表）中，尽管目标明确，但查找过程要做到高效并非时一件容易的事。

迄今为止，所有收集器在根节点枚举这一步骤时都是必须要暂停所有用户线程。现在可达性分析算法耗时最长的查找引用链的过程已经可以与用户线程一起并发。但根节点枚举时必须要停顿所有用户线程。若这点不能满足的话，分析结果的准确性就无法保证。在用户线程运行的期间内，根节点集合的对象引用关系时在不断变化的。

在HotSpot 的解决方案里，是使用一组称为`OopMap`的数据结构来达到这一目的。一旦类加载的动作完成的时候，HotSpot 就会把对象内什么偏移量上是什么类型的数据计算出来。在即时编译的过程中，也会特定的位置记录下栈里和寄存器里哪些位置是引用。 

### 安全点

在`OopMap`的协助下，HotSpot 可以快速完成 GC Roots 枚举。但可能导致引用关系变化或者说导致`OopMap`内容变化的指令非常繁多。如果为每一条指令都生成一个`OopMap`对象则需要大量的内存空间。

事实上HotSpot 只有在特定的位置记录这些信息，这些位置称为 “安全点”。

有了安全点的设定决定了用户程序执行时并非在代码流的任意位置都能够停下来开始垃圾收集的，而是强制要求必须执行到安全点后才能暂停。因此，安全点的选定不能太少让垃圾收集器等待时间过程，也不能太过频繁以至于过分增大运行运行时的内存负荷。安全点的位置选取基本上是以 ”是否具有让程序长时间执行的特征“为标准进行选定的。因为每条指令的执行时间都非常短，“长时间执行”的最明显的特征就是指令序列的复用， 例如方法调用，循环跳转，异常跳转等都属于序列复用，所以只有这些功能的指令常能才生安全点。

安全点的另一个需要考虑的问题是，如何在垃圾回收时让所有线程都跑到最近的安全点，然后停顿下来。有两种方案：

1. 抢先是中断。

   不需要线程的执行代码的组东配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程，让它执行一会在重新中断。直到跑到安全点上。现在几乎没有使用抢先中断来暂停线程响应GC事件。

2. 主动式中断。

   当垃圾收集器需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标志位，各个线程执行的过程中会不停地主动轮询这个标志位，一旦发现中断标志为真时就之际在最近的标志位主动中断挂起。轮询标志位的地方是和安全点重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集避免没有足够的内存分配新对象。

#### 主动式中断轮询的实现

由于轮询操作在代码中频繁出现，这要求它必须足够高效。HotSpot采用内存保护陷阱的方式，把轮询操作精简至只有一条汇编指令的程度。

当虚拟机需要暂停用户线程时，虚拟机把“特定的”内存页设置为不可读，当程序执行到轮询指令时就会产生一个自陷异常信号，然后再预先注册的异常处理器中挂起线程实现等待。

### 安全区域

使用安全点的设计似乎已经完美的解决了如何停顿用户线程，但实际情况却不一定，但当程序不执行时，如用户线程处于Sleep 状态时程序无法响应需虚拟机的中断请求，不能再走到安全的地方挂起自己。虚拟机不可能继续等待线程被重新激活分配处理时间。

安全区域是指能够确保再某一段代码片段中，引用关系不会发生变化，因此再这个区与的任意地方开始进行垃圾回收都是安全的，

当用户线程执行到安全区域里面的代码时，首先会标识出自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集器时就不必去管这些已经声明自己已经在安全区域内的线程了。

### 记忆集与卡表

记忆集是一种记录从非收集区域指向收集区域的指针集合的抽象数据结构，在不考虑效率和成本的情况下最简单的实现可以用非收集区域中所有跨代引用的对象数组来实现这个数据结构。

卡表是最简单的形式可以只是一个字节数组，而HotSpot虚拟机确实也是这样实现的。

```java
CRAD_TABLE[this address >> 9] = 1 
```

字节数组CRAD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存快被称作 “卡页” ，卡页的大小通常为2的 N次幂的字节数。通过上面代码可以看出HotSpot 中使用的卡页大小为2的 9次幂，即 512字节（地址右移9位，相当于用地址除以512）。

一个卡页的内存通常包含不止一个对象，只要卡页有一个（或更多）对象的字段存在着跨代指针，那就将对应的卡表的数组元素标识为1，称这个元素变脏，没有则标识为0，在垃圾收集时只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把他们加入到GC Roots 中一并扫描。

![](https://cdn.jsdelivr.net/gh/Xiaomy749/metocs_pic/202201091248486.png)

​																											图 2-1 卡表与卡页示意图

### 写屏障

卡表解决了如何实现记忆集来缩减GC Roots扫描范围的问题，但还没有解决卡表元素如何维护的问题，例如它们何时变脏、谁来把它们变脏。

```
void oop_filed_store(oop* filed,oop new_status){
	//引用字段赋值操作
	*filed = new_value;
	// 写后屏障，在这里完成卡表状态更新
	post_wirte_barrier(filed,new_value);
}
```

​																													代码 2-1 写屏障更新卡表

 应用写屏障后，虚拟机会为所有赋值操作生成相应的指令。无论是不是老年代对新生代的对象的引用，每次只要对引用进行更新就会产生额外的开销。



### 并发的可达性分析

#### 三色标记

- 白色

  表示对象尚未被垃圾收集器访问过，显然在可达性分析刚刚开始时所有的对象都是白色的，若在分析结束的阶段，仍有白色的对象，即代表不可达。

- 黑色

  表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经被扫描了，黑色对象不可能不经过灰色对象直接指向白色对象。

- 灰色

  表示对象已经被垃圾收集器访问过，但这个对象至少有有一个引用没有被扫描过。

#### 对象消失问题

即原本应被标记为黑色的对象被勿标记为白色。

- 赋值器插入一条或多条从黑色对象到白色对象的新引用。
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接的引用。

破环以上两条中的任意一条即可解决对象消失问题。由此分别产生了两种解决方案：增量更新，原始快照。

增量更新破坏第一个条件：当黑色对象插入新的指向白色对象的引用时，就将这个新插入的引用记录下来，等并发扫描结束后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。简化理解为，黑色对象一旦新插入一条指向白色对象的引用后，它就变为灰色对象了。

原始快照破坏第二个条件：当灰色的对象要删除指向白色的对象引用关系，就要将这个删除的引用记录下来，在并发扫描结束之后再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。简化理解为，无论引用关系删除与否都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。

