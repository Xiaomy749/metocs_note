---
title: Java内存区域（二）初探Java对象
date: 2021-12-06 20:10:51
tags:
- Java
- Jvm
categories:
- [Java,Jvm]
---

#### 1.对象的创建（仅限于普通对象）

Java是一门面向对象的语言。Java程序运行时过程中每时每刻都有对象被创建出来，在语言层面上，创建对象（复制与反序列化除外）仅仅时一个new关键词而。

当Java虚拟机遇到一条字节码`new`指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用。并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可完全确定下来。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。

##### 分配方式

**指针碰撞**：假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被存放在另一边，中间存放在一个指针做份分界点指示器。

那分配内存就仅仅是把这个指针向空闲方向挪动与对象大小相等的一块体积，这种分配方式称为“指针碰撞”。

**空闲列表**：如果内存空间与已使用的空间内是相互交错在一起的，那么虚拟机就必须维护一个列表，记录哪块内存是可用的，在分配的时候就在列表中找到一块足够大小的内存划分给对象，并更新列表上的记录。这种分配方式被称为“空闲列表”。

采用哪种分配方式由该区域的垃圾收集器使用的算法决定。

##### 线程安全问题

对象创建在虚拟机中是非常频繁的行为，仅仅是修改一个指针指向的位置，在并发的情况下也不是线程安全的。可能出现正在给对象A分配对象，指针还没来得及修改，对象B又同时使用原来的指针来分配内存的情况。

**解决方案**

1. 对分配空间的动作进行同步处理，虚拟机采用CAS配上失败重试的方式保证更新操作原子性。
2. 把内存分配的动作按照线程划分在不同的空间中进行，即 TLAB （虚拟机是否是使用TLAB，可以通过 `-XX:+/-UseTLAB`参数来设定）

内存分配完成后虚拟机必须将分配到的内存空间（不包括对象头）都初始化为零值。这保证了Java对象的实例字段在Java代码中可以不赋初始值就可以直接使用。

接下来，Java虚拟机还要对对象进行必要的设置，......（>__<）

#### 2.对象的内存布局

在HotSpot虚拟机中，对象在堆内存中的存储布局可以划分为三个部分

- 对象头
  - 对象自身的运行的时数据（哈希码、GC分代年龄、锁状态、线程持有的锁、偏向线程ID、偏向时间戳）
  - 类型指针（类型元数据指针）
  - （数组）记录长度数据
- 实例数据
  - 即我们在程序代码里所定义的字段，无论从父类继承还是自己定义的都会记录下来（存储顺序收参数 `-XX:FieldsAllocationStyle` 和定义顺序影响）默认为 : `longs`/`doubles`、`int`、`shorts`、`chars`、`bytes`/`booleans`、`oops`   相同宽度的字段总会被分配到一起，父类变量会存储在子类之前
  - （`+XX:CompactFileds` 参数 值为 `true` 子类较窄的变量允许插入父类变量的空隙中，以节省空间 默认为 `true`）
- 对齐补充
  - 不是必然的，也没有特别的含义，是一个占位符。HotSpot  虚拟机自动内存管理系统的要求对象其实地址必须是8字节的整数倍，因此需要对其补充。

#### 对象访问定位

创建对象自然是为了后续使用该对象。Java程序会通过栈上的 `reference` 数据来操作堆上的具体对象

**主流的对象访问方式**

- 句柄访问

  - Java堆划分一部分内存作为句柄池，`reference`中存储的是对象的句柄地址，句柄中包含对象的实例数据与类型数据的地址信息

    ![](https://cdn.jsdelivr.net/gh/Xiaomy749/metocs_pic/202112122140271.png)

  图 2-1 通过句柄访问对象

  优势：`reference`存储句柄地址对象的的移动不会改变`reference`本身

- 指针访问

  - `reference`保存对象地址信息。

    ![](https://cdn.jsdelivr.net/gh/Xiaomy749/metocs_pic/202112122140099.png)

  图 2-2 通过直接指针访问对象

  优势：访问速度快，节省了一次指针定位的开销

HotSpot 虚拟机采用第二中方式。



